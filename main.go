package main

import (
	"bytes"
	"fmt"
	"os"
	"path"
	"regexp"
)

// do not forget to reset this after writing to the file
var b bytes.Buffer

var simp = []byte("simp")

type line struct {
	// if home is true then content should be exactly what will be printed
	// this means you have some responsibility to fix up content
	content []byte
	// if true then we are dealing with the home language
	// if false then the markup language
	home bool
}

type simpdef struct {
	name []byte
	args []arg
}

type arg struct {
	name []byte
	typ []byte
}

func writeargs(b *bytes.Buffer, as []arg, includetype bool) {
	for i, a := range as {
		b.Write(a.name)
		if includetype {
			b.WriteRune(' ')
			b.Write(a.typ)
		}
		if i < len(as) - 1 {
			b.WriteString(", ")
		}
	}
}


type fileinfo struct {
	lines []line
	simpdefs []simpdef
}

func changefilename(s string) string {
	i := len(s) - 1
	for ; i > 0; i-- {
		if s[i] == '.' {
			break
		}
	}
	return s[:i] + "_simp.go"
}

func main() {
	args := os.Args[1:]
	b.Grow(50_000)
	for _, p := range args {
		ext := path.Ext(p)
		if ext != ".simp" {
			fmt.Println("warning,", p, "does not have the right file extension '.simp'")
			continue
		}
		file, err := os.ReadFile(p)
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
		transform(file)
		nn := changefilename(p)
		out, err := os.Create(nn)
		if err != nil {
			fmt.Println(err)
			os.Exit(2)
		}
		println(b.Len())
		out.Write(b.Bytes())
		out.Sync()
		b.Reset()
	}
	return
}

func transform(bs []byte) {
	fi := getLinesContent(bs)
	addLinesType(&fi)
	printLines(&fi)
}

func getLinesContent(bs []byte) fileinfo {
	fi := fileinfo{}
	linestart := 0
	fi.lines = make([]line, 0, 50)
	for i := 0; i < len(bs); i++ {
		if bs[i] != '\n' {
			continue
		}
		fi.lines = append(fi.lines, line{content: bs[linestart : i+1]})
		linestart = i + 1
	}
	return fi
}

var nameregex = regexp.MustCompile(`\w+`)
var tupregex = regexp.MustCompile(`\(.*\)`)
// expects input to be a buffer that starts with (
// basically start the buffer after the name of the function
func extractargs(b []byte) []arg {
	t := tupregex.Find(b)
	t = t[1:len(t)-1] // remove starting and ending paren
	c := bytes.Split(t, []byte(","))
	args := []arg{}
	for _, v := range c {
		v := bytes.TrimSpace(v)
		pair := bytes.SplitN(v, []byte(" "), 2)
		args = append(args, arg{
			name: pair[0],
			typ: pair[1],
		})
	}
	return args
}
func addLinesType(fi *fileinfo) {
	home := true
	for i := range fi.lines {
		l := &fi.lines[i]
		cnt := l.content
		if home == false {
			if cnt[0] == '}' {
				home = true
				l.home = true
			} else if cnt[0] == '@' {
				l.home = true
			}
			continue
		}
		l.home = home
		ln := len(cnt) > len(simp)
		if ln && bytes.Equal(cnt[0:len(simp)], simp) {
			copy(cnt[0:len(simp)], "func ")
			cnt := cnt[len(simp):]
			home = false
			name :=  nameregex.Find(cnt)
			cnt = cnt[len(name):]
			args :=  extractargs(cnt)
			fi.simpdefs = append(fi.simpdefs, simpdef{
				name: name,
				args: args,
			})
		}
	}
}

var varregex = regexp.MustCompile(`([^@]|^)@([\w().]+)`)
var dubreg = regexp.MustCompile(`@@`)

func printLines(fi *fileinfo) {
	cnt := string(fi.lines[0].content)
	cnt = string(cnt[0:len(cnt)-1]) + "// DO NOT EDIT - AUTOGENERATED\n"
	fi.lines[0].content = []byte(cnt)
	size := 0
	for _, l := range fi.lines {
		size += len(l.content)
	}
	for _, l := range fi.lines {
		if l.home {
			res := l.content
			if l.content[0] == '@' {
				res = res[1:]
			}
			b.Write(res)
		} else {
			b.WriteString("b.Write([]byte(\"")

			c := l.content[:len(l.content)-1]
			r := varregex.ReplaceAll(c, []byte(`$1" + fmt.Sprint($2) + "`))
			r = dubreg.ReplaceAll(r, []byte(`@`))
			b.Write(r)
			b.WriteString("\\n\"))\n")
		}
	}
	b.WriteString("// BEGIN STUBS: \n")
	b.WriteString("var b bytes.Buffer\n")
	for _,s := range fi.simpdefs {
		as := s.args[1:]

		b.WriteString("func ")
		b.Write(s.name)
		b.WriteString("str")
		b.WriteRune('(')
		writeargs(&b, as, true)
		b.WriteRune(')')
		b.WriteString("string {\n")
		b.WriteString("var bb bytes.Buffer\n")
		b.Write(s.name)
		b.WriteRune('(')
		b.WriteString("&bb")
		if len(as) > 0 { 
			b.WriteString(", ")
		}
		writeargs(&b, as, false)
		b.WriteRune(')')
		b.WriteString("\n")
		b.WriteString("return bb.String()\n")
		b.WriteString("}\n")

		// experiment
		b.WriteString("func ")
		b.Write(s.name)
		b.WriteString("fr")
		b.WriteRune('(')
		writeargs(&b, as, true)
		b.WriteRune(')')
		b.WriteString("string {\n")
		b.Write(s.name)
		b.WriteRune('(')
		b.WriteString("&b")
		if len(as) > 0 { 
			b.WriteString(", ")
		}
		writeargs(&b, as, false)
		b.WriteRune(')')
		b.WriteString("\n")
		b.WriteString("s := b.String()\n")
		b.WriteString("b.Reset()\n")
		b.WriteString("return s\n")
		b.WriteString("}\n")

	}
}
